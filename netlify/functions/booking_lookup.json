#!/usr/bin/env node
/**
 * BOOKING LINK FINDER
 * 
 * Takes restaurants from popular_nyc.json that are NOT in booking_lookup.json,
 * generates likely Resy/OpenTable/Tock URLs, checks if they exist (HTTP 200),
 * and adds the first valid match. ONE link per restaurant, priority: Resy > OpenTable > Tock.
 * 
 * Run from: netlify/functions/
 *   node find_booking_links.js
 * 
 * Requires: Node 18+ (native fetch)
 */

const fs = require('fs');
const path = require('path');

const POPULAR_PATH = path.join(__dirname, 'popular_nyc.json');
const BOOKING_PATH = path.join(__dirname, 'booking_lookup.json');
const BACKUP_PATH = path.join(__dirname, 'booking_lookup.pre_find.json');
const REPORT_PATH = path.join(__dirname, 'booking_find_report.json');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CONCURRENCY = 6;        // parallel requests
const DELAY_MS = 250;         // delay between batches
const TIMEOUT_MS = 5000;      // per-request timeout
const MAX_RESTAURANTS = 0;    // 0 = process all

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

function normalize(name) {
  return (name || '').toLowerCase().trim()
    .replace(/\s*[-â€“â€”]\s*(midtown|downtown|uptown|east village|west village|tribeca|soho|noho|brooklyn|queens|fidi|financial district|nomad|lincoln square|nyc|new york|manhattan|ny).*$/i, '')
    .replace(/\s+(restaurant|ristorante|nyc|ny|new york|bar & restaurant|bar and restaurant|bar & grill|bar and grill|steakhouse|trattoria|pizzeria|cafe|cafÃ©|bistro|brasserie|kitchen|dining|room)$/i, '')
    .replace(/^the\s+/, '')
    .trim();
}

function slugify(name) {
  return (name || '').toLowerCase().trim()
    .replace(/['']/g, '')          // remove apostrophes
    .replace(/&/g, 'and')          // & â†’ and
    .replace(/Ã©/g, 'e')
    .replace(/Ã¨/g, 'e')
    .replace(/Ãª/g, 'e')
    .replace(/Ã«/g, 'e')
    .replace(/Ã¡/g, 'a')
    .replace(/Ã /g, 'a')
    .replace(/Ã¢/g, 'a')
    .replace(/Ã£/g, 'a')
    .replace(/Ã¤/g, 'a')
    .replace(/Ã­/g, 'i')
    .replace(/Ã¬/g, 'i')
    .replace(/Ã®/g, 'i')
    .replace(/Ã¯/g, 'i')
    .replace(/Ã³/g, 'o')
    .replace(/Ã²/g, 'o')
    .replace(/Ã´/g, 'o')
    .replace(/Ã¶/g, 'o')
    .replace(/Ãµ/g, 'o')
    .replace(/Ãº/g, 'u')
    .replace(/Ã¹/g, 'u')
    .replace(/Ã»/g, 'u')
    .replace(/Ã¼/g, 'u')
    .replace(/Ã±/g, 'n')
    .replace(/Ã§/g, 'c')
    .replace(/Ä‘/g, 'd')
    .replace(/[^\w\s-]/g, '')      // remove special chars
    .replace(/\s+/g, '-')          // spaces â†’ hyphens
    .replace(/-+/g, '-')           // collapse multiple hyphens
    .replace(/^-|-$/g, '');         // trim hyphens
}

// Check if a URL returns 200 (with redirect following)
async function checkUrl(url) {
  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), TIMEOUT_MS);
    
    const resp = await fetch(url, {
      method: 'HEAD',
      signal: controller.signal,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Accept': 'text/html,application/xhtml+xml',
      },
      redirect: 'follow'
    });
    
    clearTimeout(timeout);
    
    // Some sites return 403 for HEAD, try GET
    if (resp.status === 403 || resp.status === 405) {
      const controller2 = new AbortController();
      const timeout2 = setTimeout(() => controller2.abort(), TIMEOUT_MS);
      
      const resp2 = await fetch(url, {
        method: 'GET',
        signal: controller2.signal,
        headers: {
          'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
          'Accept': 'text/html',
        },
        redirect: 'follow'
      });
      
      clearTimeout(timeout2);
      
      // Read a tiny bit to not hang
      const text = await resp2.text().catch(() => '');
      
      // Check for soft 404 pages
      if (resp2.ok && !text.includes('page not found') && !text.includes('404') && !text.includes('no longer available')) {
        return { valid: true, status: resp2.status, finalUrl: resp2.url };
      }
      return { valid: false, status: resp2.status };
    }
    
    if (resp.ok) {
      return { valid: true, status: resp.status, finalUrl: resp.url };
    }
    
    return { valid: false, status: resp.status };
  } catch (err) {
    return { valid: false, status: 0, error: err.message };
  }
}

// Generate candidate URLs for a restaurant
function generateCandidates(name) {
  const slug = slugify(name);
  const candidates = [];
  
  // Skip if slug is too short
  if (slug.length < 2) return candidates;
  
  // â”€â”€â”€ RESY candidates (highest priority) â”€â”€â”€
  candidates.push({
    platform: 'resy',
    url: `https://resy.com/cities/ny/${slug}`
  });
  
  // Try with -new-york suffix (some Resy URLs have this)
  candidates.push({
    platform: 'resy',
    url: `https://resy.com/cities/ny/${slug}-new-york`
  });
  
  // â”€â”€â”€ OPENTABLE candidates â”€â”€â”€
  // OpenTable uses /r/slug-new-york or just /slug
  candidates.push({
    platform: 'opentable',
    url: `https://www.opentable.com/r/${slug}-new-york`
  });
  
  candidates.push({
    platform: 'opentable',
    url: `https://www.opentable.com/r/${slug}-brooklyn`
  });
  
  // Some OpenTable URLs don't have /r/ prefix
  candidates.push({
    platform: 'opentable',
    url: `https://www.opentable.com/${slug}`
  });
  
  // â”€â”€â”€ TOCK candidates â”€â”€â”€
  // Tock uses exploretock.com/slug (no hyphens usually, concatenated)
  const tockSlug = slug.replace(/-/g, '');
  candidates.push({
    platform: 'tock',
    url: `https://www.exploretock.com/${tockSlug}`
  });
  
  // Also try with hyphens
  candidates.push({
    platform: 'tock',
    url: `https://www.exploretock.com/${slug}`
  });
  
  return candidates;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function main() {
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('BOOKING LINK FINDER');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

  // Load popular restaurants
  let popular;
  try {
    popular = JSON.parse(fs.readFileSync(POPULAR_PATH, 'utf8'));
    console.log(`âœ… Popular restaurants: ${popular.length} entries`);
  } catch (err) {
    console.error(`âŒ Cannot load ${POPULAR_PATH}: ${err.message}`);
    process.exit(1);
  }

  // Load existing booking lookup
  let booking = {};
  try {
    booking = JSON.parse(fs.readFileSync(BOOKING_PATH, 'utf8'));
    console.log(`âœ… Existing booking lookup: ${Object.keys(booking).length} entries`);
  } catch (err) {
    console.log('âš ï¸ No existing booking_lookup.json â€” starting fresh');
  }

  // Backup
  if (Object.keys(booking).length > 0) {
    fs.writeFileSync(BACKUP_PATH, JSON.stringify(booking, null, 2));
    console.log(`ğŸ’¾ Backup saved to booking_lookup.pre_find.json`);
  }

  // Find restaurants NOT in booking lookup
  const missing = [];
  for (const r of popular) {
    if (!r.name) continue;
    const norm = normalize(r.name);
    const nameLower = r.name.toLowerCase().trim();
    
    // Check if already in lookup
    if (booking[norm] || booking[nameLower]) continue;
    
    // Also check if it already has a booking link from the sweep
    if (r.booking_url && r.booking_platform) continue;
    
    missing.push(r);
  }

  let toProcess = missing;
  if (MAX_RESTAURANTS > 0) {
    toProcess = missing.slice(0, MAX_RESTAURANTS);
  }

  console.log(`\nğŸ“Š ${missing.length} restaurants missing booking links`);
  console.log(`   Processing: ${toProcess.length}`);
  console.log(`   Concurrency: ${CONCURRENCY}`);
  console.log(`   Estimated time: ~${Math.ceil(toProcess.length / CONCURRENCY * (DELAY_MS + TIMEOUT_MS) / 60000)} minutes\n`);

  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('SEARCHING FOR BOOKING LINKS');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  let found = 0;
  let notFound = 0;
  let errors = 0;
  const results = [];

  // Process in batches
  for (let i = 0; i < toProcess.length; i += CONCURRENCY) {
    const batch = toProcess.slice(i, i + CONCURRENCY);
    
    const promises = batch.map(async (restaurant) => {
      const name = restaurant.name;
      const candidates = generateCandidates(name);
      
      for (const candidate of candidates) {
        const result = await checkUrl(candidate.url);
        
        if (result.valid) {
          // Verify the final URL is actually a restaurant page, not a redirect to homepage
          const finalUrl = result.finalUrl || candidate.url;
          const isHomepage = finalUrl === 'https://resy.com/' || 
                           finalUrl === 'https://www.opentable.com/' ||
                           finalUrl === 'https://www.exploretock.com/' ||
                           finalUrl.endsWith('/cities/ny') ||
                           finalUrl.endsWith('/cities/ny/');
          
          if (isHomepage) continue;
          
          // Found a valid booking link!
          const norm = normalize(name);
          const nameLower = name.toLowerCase().trim();
          
          // Add to booking lookup (both normalized and original)
          booking[norm] = { platform: candidate.platform, url: candidate.url };
          if (nameLower !== norm) {
            booking[nameLower] = { platform: candidate.platform, url: candidate.url };
          }
          
          found++;
          const pct = Math.round((i + batch.indexOf(restaurant) + 1) / toProcess.length * 100);
          console.log(`  âœ… [${pct}%] ${name} â†’ ${candidate.platform}: ${candidate.url}`);
          
          results.push({
            name,
            platform: candidate.platform,
            url: candidate.url,
            status: 'found'
          });
          
          return; // First match wins â€” stop checking other candidates
        }
      }
      
      // No valid link found
      notFound++;
      const pct = Math.round((i + batch.indexOf(restaurant) + 1) / toProcess.length * 100);
      if (notFound <= 10 || notFound % 50 === 0) {
        console.log(`  âŒ [${pct}%] ${name} â€” no booking link found`);
      }
      
      results.push({
        name,
        status: 'not_found'
      });
    });
    
    await Promise.all(promises);
    
    // Progress update every 50 restaurants
    const processed = Math.min(i + CONCURRENCY, toProcess.length);
    if (processed % 50 === 0 || processed === toProcess.length) {
      console.log(`\n  ğŸ“Š Progress: ${processed}/${toProcess.length} | Found: ${found} | Not found: ${notFound}\n`);
    }
    
    await sleep(DELAY_MS);
  }

  // Save updated booking lookup
  fs.writeFileSync(BOOKING_PATH, JSON.stringify(booking, null, 2));

  const totalEntries = Object.keys(booking).length;

  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('RESULTS');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log(`  Restaurants checked:  ${toProcess.length}`);
  console.log(`  âœ… Found booking link: ${found}`);
  console.log(`  âŒ No link found:      ${notFound}`);
  console.log(`  Total booking entries: ${totalEntries} (was ${totalEntries - found * 2})`);

  // Platform breakdown
  const byPlatform = { resy: 0, opentable: 0, tock: 0 };
  for (const r of results) {
    if (r.platform) byPlatform[r.platform]++;
  }
  console.log(`\n  By platform:`);
  console.log(`    Resy:      ${byPlatform.resy}`);
  console.log(`    OpenTable: ${byPlatform.opentable}`);
  console.log(`    Tock:      ${byPlatform.tock}`);

  console.log(`\nğŸ’¾ Updated booking_lookup.json: ${totalEntries} entries`);
  console.log(`ğŸ’¾ Backup at booking_lookup.pre_find.json`);

  // Save report
  const report = {
    timestamp: new Date().toISOString(),
    checked: toProcess.length,
    found,
    notFound,
    byPlatform,
    totalEntries,
    newLinks: results.filter(r => r.status === 'found')
  };
  fs.writeFileSync(REPORT_PATH, JSON.stringify(report, null, 2));
  console.log(`ğŸ“„ Report saved to booking_find_report.json`);

  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('NEXT STEPS');
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('1. Review booking_find_report.json for new links');
  console.log('2. Commit and push: git add booking_lookup.json && git commit -m "Expand booking links" && git push');
  console.log('3. Also add booking_lookup.json to netlify.toml includes if not already there');
}

main().catch(err => {
  console.error('âŒ Fatal error:', err);
  process.exit(1);
});
