  ];

  for (const p of candidates) {
    try {
      if (fs.existsSync(p)) {
        const raw = fs.readFileSync(p, 'utf8');
        MICHELIN_DATA = JSON.parse(raw);
        console.log(`✅ Loaded ${MICHELIN_DATA.length} Michelin entries from: ${p}`);
        return;
      }
    } catch (err) {
      console.warn(`⚠️ Michelin load failed at ${p}: ${err.message}`);
    }
  }

  console.warn('⚠️ Michelin data not found. Continuing without Michelin badges.');
}

loadMichelin();

function normalizeName(name) {
  return String(name || '')
    .toLowerCase()
    .replace(/[^\w\s]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}

// Adds place.michelin = { distinction, stars } when matched
function attachMichelinData(candidates) {
  if (!Array.isArray(candidates) || MICHELIN_DATA.length === 0) return;

  candidates.forEach(place => {
    const placeName = normalizeName(place.name);

    for (const michelin of MICHELIN_DATA) {
      const michelinName = normalizeName(michelin.name);

      // 1) Exact normalized name match
      if (placeName === michelinName) {
        place.michelin = { distinction: michelin.distinction, stars: michelin.stars };
        return;
      }

      // 2) Contains match with length guard (helps "Le Bernardin" etc.)
      if (placeName.includes(michelinName) || michelinName.includes(placeName)) {
        if (Math.abs(placeName.length - michelinName.length) <= 5) {
          place.michelin = { distinction: michelin.distinction, stars: michelin.stars };
          return;
        }
      }

      // 3) Coordinate proximity (<= 60 meters)
      if (
        typeof michelin.lat === 'number' &&
        typeof michelin.lng === 'number' &&
        place?.geometry?.location &&
        typeof place.geometry.location.lat === 'number' &&
        typeof place.geometry.location.lng === 'number'
      ) {
        const R = 6371000;
        const dLat = (place.geometry.location.lat - michelin.lat) * Math.PI / 180;
        const dLon = (place.geometry.location.lng - michelin.lng) * Math.PI / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(michelin.lat * Math.PI / 180) *
            Math.cos(place.geometry.location.lat * Math.PI / 180) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const distance = R * c;

        if (distance <= 60) {
          place.michelin = { distinction: michelin.distinction, stars: michelin.stars };
          return;
        }
      }
    }
  });
}
// ===== END MICHELIN OVERLAY =====
