
let MICHELIN_DATA = [];

function safeLoadJson(filePath) {
  try {
    if (!fs.existsSync(filePath)) return null;
    const raw = fs.readFileSync(filePath, "utf8");
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : null;
  } catch (e) {
    console.warn("[Michelin] Failed reading/parsing:", filePath, e.message);
    return null;
  }
}

(function loadMichelinOnce() {
  // In a Netlify function, __dirname is the folder where THIS function file lives.
  // If michelin_nyc.json is inside netlify/functions/, this will work.
  const p1 = path.join(__dirname, "michelin_nyc.json");

  // Extra fallback in case bundling/pathing changes:
  const p2 = path.join(process.cwd(), "netlify", "functions", "michelin_nyc.json");

  const loaded = safeLoadJson(p1) || safeLoadJson(p2);

  if (loaded) {
    MICHELIN_DATA = loaded;
    console.log(`[Michelin] Loaded entries: ${MICHELIN_DATA.length}`);
    console.log(`[Michelin] Sample: ${MICHELIN_DATA.slice(0, 3).map(x => x.name).join(", ")}`);
  } else {
    MICHELIN_DATA = [];
    console.warn("[Michelin] michelin_nyc.json NOT FOUND or invalid.");
    console.warn("[Michelin] Tried:", p1, "and", p2);
  }
})();

function normalizeName(name) {
  return String(name || "")
    .toLowerCase()
    .replace(/[^\w\s]/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

function attachMichelinData(candidates) {
  console.log("=== MICHELIN MATCHING ===");
  console.log(`[Michelin] Entries loaded: ${MICHELIN_DATA.length}`);

  if (!MICHELIN_DATA.length) return;
  if (!Array.isArray(candidates) || !candidates.length) return;

  let matched = 0;

  for (const place of candidates) {
    const placeName = normalizeName(place.name);

    for (const michelin of MICHELIN_DATA) {
      const michelinName = normalizeName(michelin.name);

      // 1) Exact normalized name match
      if (placeName === michelinName) {
        place.michelin = {
          distinction: michelin.distinction,
          stars: michelin.stars
        };
        matched++;
        break;
      }

      // 2) Fuzzy contains match with length guard
      if (placeName.includes(michelinName) || michelinName.includes(placeName)) {
        if (Math.abs(placeName.length - michelinName.length) <= 5) {
          place.michelin = {
            distinction: michelin.distinction,
            stars: michelin.stars
          };
          matched++;
          break;
        }
      }

      // 3) Coordinate proximity (within 75 meters)
      // NOTE: This only works if your place has geometry.location.lat/lng
      if (michelin.lat && michelin.lng && place.geometry?.location) {
        const R = 6371000;
        const dLat = (place.geometry.location.lat - michelin.lat) * Math.PI / 180;
        const dLon = (place.geometry.location.lng - michelin.lng) * Math.PI / 180;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(michelin.lat * Math.PI / 180) *
            Math.cos(place.geometry.location.lat * Math.PI / 180) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const dist = R * c;

        if (dist <= 75) {
          place.michelin = {
            distinction: michelin.distinction,
            stars: michelin.stars
          };
          matched++;
          break;
        }
      }
    }
  }

  console.log(`Michelin restaurants matched: ${matched}`);
}
